<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Jamie Wright</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        /* make the document background transparent so the canvas can show through */
        background: transparent;
        color: white;
        font-family: sans-serif;
      }
      /* make the canvas a full-viewport background behind page content */
      canvas {
        position: fixed;
        inset: 0; /* top:0; right:0; bottom:0; left:0; */
        width: 100%;
        height: 100%;
        display: block;
        background-color: black;
        z-index: -1; /* place behind regular content */
        pointer-events: none; /* allow clicks on page content through the canvas */
      }
    </style>
  </head>
  <body>
    <h1>Jamie Wright</h1>
    <canvas id="noiseCanvas"></canvas>
    <script>
      // WebGL fragment shader port of the Godot shader (fragment-only)
      const canvas = document.getElementById("noiseCanvas");
      const gl = canvas.getContext("webgl");
      if (!gl) throw new Error("WebGL not supported");

      function hexToRgba(hex) {
        if (!hex) return [0, 0, 0, 0];
        let s = String(hex).trim();
        if (s[0] === "#") s = s.slice(1);
        if (s.length === 3)
          s =
            s
              .split("")
              .map((c) => c + c)
              .join("") + "ff";
        else if (s.length === 4)
          s = s
            .split("")
            .map((c) => c + c)
            .join("");
        else if (s.length === 6) s = s + "ff";
        else if (s.length !== 8) return [0, 0, 0, 0];
        return [
          parseInt(s.slice(0, 2), 16) / 255,
          parseInt(s.slice(2, 4), 16) / 255,
          parseInt(s.slice(4, 6), 16) / 255,
          parseInt(s.slice(6, 8), 16) / 255,
        ];
      }

      async function loadShaderSources() {
        try {
          const [vsText, fsText] = await Promise.all([
            fetch("shaders/quad.vert").then((r) => r.text()),
            fetch("shaders/fractal.frag").then((r) => r.text()),
          ]);
          return { vs: vsText, fs: fsText };
        } catch (e) {
          console.warn("Fetching shaders failed", e);
        }
      }

      function compileShader(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
          throw new Error(gl.getShaderInfoLog(s));
        return s;
      }

      // Asynchronously load shader sources (external files preferred), compile and link
      async function createProgramFromSources() {
        const sources = await loadShaderSources();
        const prog = gl.createProgram();
        gl.attachShader(prog, compileShader(gl.VERTEX_SHADER, sources.vs));
        gl.attachShader(prog, compileShader(gl.FRAGMENT_SHADER, sources.fs));
        gl.bindAttribLocation(prog, 0, "a_pos");
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
          throw new Error(gl.getProgramInfoLog(prog));
        gl.useProgram(prog);
        return prog;
      }

      // build program and then continue initialization
      let prog;
      createProgramFromSources()
        .then((p) => {
          prog = p;
          // After program is ready we need to re-query uniform locations and start rendering.
          initializeAfterProgramReady(prog);
        })
        .catch((err) => {
          console.error("Failed to create GL program:", err);
        });

      // quad
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
        gl.STATIC_DRAW
      );
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

      // Defer uniform location queries until the program is ready.
      let u_resolution, u_time, u_pixelation, u_zoom, u_gradient_pixelation;
      let u_background_threshold, u_color_low_threshold, u_color_mid_threshold;
      let u_color_low, u_color_mid, u_color_high;

      function initializeAfterProgramReady(program) {
        // uniforms
        u_resolution = gl.getUniformLocation(program, "resolution");
        u_time = gl.getUniformLocation(program, "time");
        u_pixelation = gl.getUniformLocation(program, "pixelSize");
        u_zoom = gl.getUniformLocation(program, "zoom");
        u_gradient_pixelation = gl.getUniformLocation(program, "gradientStep");
        u_background_threshold = gl.getUniformLocation(
          program,
          "backgroundThreshold"
        );
        u_color_low_threshold = gl.getUniformLocation(
          program,
          "colorLowThreshold"
        );
        u_color_mid_threshold = gl.getUniformLocation(
          program,
          "colorMidThreshold"
        );
        u_color_low = gl.getUniformLocation(program, "colorLow");
        u_color_mid = gl.getUniformLocation(program, "colorMid");
        u_color_high = gl.getUniformLocation(program, "colorHigh");

        // start rendering loop (program is ready)
        requestAnimationFrame(render);
      }

      // defaults (same as CPU version)
      const defaults = {
        speed: 0.0125,
        pixelation: 16.0,
        zoom: 1.0,
        gradient_pixelation: 0.05,
        background_threshold: 0.0,
        color_low_threshold: 0.24,
        color_mid_threshold: 0.48,
        color_low: "#038280",
        color_mid: "#037382",
        color_high: "#000000",
      };

      function resize() {
        const devicePixelRatio = Math.max(1, window.devicePixelRatio || 1);
        const displayWidth = Math.floor(canvas.clientWidth * devicePixelRatio);
        const displayHeight = Math.floor(
          canvas.clientHeight * devicePixelRatio
        );
        if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
          canvas.width = displayWidth;
          canvas.height = displayHeight;
          gl.viewport(0, 0, canvas.width, canvas.height);
        }
      }

      function setColorUniform(loc, hex) {
        const c = hexToRgba(hex);
        gl.uniform4f(loc, c[0], c[1], c[2], c[3]);
      }

      function render(t) {
        resize();
        const seconds = t * 0.001 * defaults.speed;
        gl.uniform2f(u_resolution, canvas.width, canvas.height);
        gl.uniform1f(u_time, seconds);
        gl.uniform1f(u_pixelation, defaults.pixelation);
        gl.uniform1f(u_zoom, defaults.zoom);
        gl.uniform1f(u_gradient_pixelation, defaults.gradient_pixelation);
        gl.uniform1f(u_background_threshold, defaults.background_threshold);
        gl.uniform1f(u_color_low_threshold, defaults.color_low_threshold);
        gl.uniform1f(u_color_mid_threshold, defaults.color_mid_threshold);
        setColorUniform(u_color_low, defaults.color_low);
        setColorUniform(u_color_mid, defaults.color_mid);
        setColorUniform(u_color_high, defaults.color_high);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
  </body>
</html>
